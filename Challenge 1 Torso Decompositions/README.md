<image src="../images/torso.png" align="center" alt="Challange 1: Torso Decompositions"/>

# Challenge 1: Torso Decompositions

This challenge is part of the [SpOC (Space Optimisation Challenge)](https://www.esa.int/gsp/ACT/projects/spoc-2024)
organised by ESA's Advanced Concepts Team and hosted in [GECCO 2024](https://gecco-2024.sigevo.org/HomePage).

## Introduction

Before we can start designing astonishing megastructures in the GRAIL
or OASIS project, we need to arrange the building blocks
suitably. These blocks, called nodes or vertices, are bound to
specific pairwise interactions. Some blocks clearly belong to the same
part of the megastructure, while others share no interaction. For an
effective and energy-efficient structure setup, it is critical to
identify an ordering of the nodes that indicates parts of the structure that can be
assembled concurrently, and that encodes a global blueprint for recursively
constructing the megastructure. At the Graph Reduction Algorithm for
Planetary-scale Hyper-optimisation (GRAPH) meta-project, we develop
the toolkit for exactly this task â€“ and we hope that engaged scientists and
engineers like you will help us to complete the project in time!

## Input


The input to this challenge is an undirected graph $G$, given as simple edge list.
We will always assume that the vertex set of a
graph with $n$ vertices is $V(G)=\{0,1,2,3,...,n-1\}$. For instance, the following graph 

<image src="https://api.optimize.esa.int/data/spoc3/torso/img/torso-graph.svg" align="center"  alt="Simple graph." /> 

would be presented as:

```
0 1
0 2
1 6
2 8
3 8
3 9
4 5
4 6
4 7
```

It will be granted that the graph is *connected* and that the used node names are consecutive, i.e., the vertex set is $V(G)=\{0,\dots,n-1\}$ and $n-1$ is the largest number appearing in any line. The three graphs for the three problems can be found here [easy](https://api.optimize.esa.int/data/spoc3/torso/easy.gr), 
[medium](https://api.optimize.esa.int/data/spoc3/torso/medium.gr), and
[hard](https://api.optimize.esa.int/data/spoc3/torso/hard.gr).


All files and data can be conveniently found on the accompanying
[GitHub repository](https://github.com/esa/SpOC3).

## Output

The decision vector $x$ that you need to compute
contains $n+1$ **integer** entries if the graph contains
$n$ nodes. The first $n$ entries should define a *permutation* of
the vertex set. The last element in the decision vector is a
*threshold value* $t\in\{0,\dots,n-1\}$. In detail, if the graph has $n$ nodes (and thus vertices $V(G)=\{0,\dots,n-1\}$), the decision vector must look like:

$x = [p_1, p_2, \dots, p_n, t]$

with $p_i\neq p_j$ for all $i\neq j$ and $p_i\in\{0,\dots,n-1\}$. The value $t$ is an integer from $\{0,\dots,n-1\}$.


## Orienting the Graph

The permutation naturally induces an orientation of the edges, namely
an edge $\{u,v\}$ is oriented $(u,v)$ if and only if $u$ appears before $v$ in the permutation. For instance, the decision vector $x=[0,1,2,4,5,3,6,8,9,7,6]$ for the problem above implies:

<image src="https://api.optimize.esa.int/data/spoc3/torso/img/torso-permutation.svg" align="center"  alt="Orientation of the graph."/> 

We let the ordering enforces new edges by the following
procedure: Scan the permutation from left to right and, whenever you
encounter a node $u$ with two outgoing edges to, say, $v$ and $w$ such
that $v$ and $w$ are not yet connected by an edge, insert the edge
$\{v,w\}$ and orient it according to the permutation. In the example we would add the red edges:

<image src="https://api.optimize.esa.int/data/spoc3/torso/img/torso-filled-permutation.svg" align="center"  alt="Edges generated by the elimination process."/> 

The last $n-t$ elements of the permutation are called *the torso*, i.e., the
*size* of the torso is $n-t$. Let the
*width* of the torso be the maximum outdegree any vertex within the
torso has (including the new edges). For instance, the permutation above with $t=6$ defines a torso of
*size* 4 and *width* 2.

## Objective

This optimization problem has *two* objectives:

1. **Maximizing the Size of the Torso:** the number of nodes in the
   torso should be as large as possible. Hence, the number
   $t\in\{0,\dots,n-1\}$ needs to be as *small as possible*.
2. **Minimizing the Width of the Torso:** the maximum outdegree of any
   node within the torso (last $n-t$ nodes of the permutation)
   should be as small as possible.

We are interested in the best possible trade-offs between those two
objectives which also satisfies the aforementioned
constraints. Consequently, you are tasked to submit a set of optimal
trade-off solutions (e.g., a list of multiple different decision
vectors) which should approximate the Pareto frontier of the
problem. The quality of your approximated Pareto frontier will then be
assessed by the [hypervolume indicator](https://esa.github.io/pygmo2/tutorials/hypervolume.html). To ensure quick evaluation, we guarantee that the width of the whole permutation (not only the torso) is always *at most 500*, and we will score worse solution as if they would have a width of 501. 

## Submitting

Your solution is allowed to contain up to **20 decision vectors** $x_1,x_2,\dots,x_{20}$. To submit a solution,  prepare a simple text / JSON file with the following content:

```
  [
    {
      "decisionVector": [ x1, x2, ... , x20 ],
      "problem": "{problem}",
      "challenge": "spoc-3-torso-decompositions",
    }
  ] 
```

Each of the decision vectors here is a vector $x=[p_1,p_2,\dots,p_n,t]$ as defined above. Mind the `{problem}` that needs to be replaced by the actual problem id, i.e., `small-graph`, `medium-graph`,  or `large-graph`. Once the file is ready, you can [submit it](https://optimize.esa.int/submit). In case you use Python, you can also use
 the [submission helper](https://api.optimize.esa.int/data/tools/submission_helper.py) via

```python
from submisson_helper import create_submission
create_submission("spoc-3-torso-decompositions","{problem}",x,"submission_file.json","submission_name","submission_description")
```

## Utilities / Hints

* We will be using [GitHub](https://github.com/esa/SpOC3) as our hub for communication with competitors. Our primary means of communication will be the [Discussions](https://github.com/esa/SpOC3/discussions) feature on our repository.


* To decode the information from a decision vector `x` into a summary printed on screen, call `udp.pretty(x)`. 

* Basic plots for solution visualisation purposes can be obtained by calling `udp.plot(x)`.

* An example chromosome is provided in the source code and can be evaluated by calling `udp.example()`. Please note that this solution corresponds to a minimal working example and should not be taken as a baseline for what the winning score should be.
